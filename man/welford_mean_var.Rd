% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/welford.R
\name{welford_mean_var}
\alias{welford_mean_var}
\title{Compute mean and variance incrementally using Welford's algorithm}
\usage{
welford_mean_var(sample_fn, n_samples, ...)
}
\arguments{
\item{sample_fn}{A function with signature `function(i, ...)` that returns a
named numeric vector for the i-th sample. The function receives the
iteration index and any additional arguments passed via `...`.}

\item{n_samples}{Number of samples to generate.}

\item{...}{Additional arguments passed to `sample_fn`.}
}
\value{
A list with two components:
  \describe{
    \item{mean}{Named numeric vector of sample means}
    \item{variance}{Named numeric vector of sample variances (variance of the mean)}
  }
}
\description{
This function provides a memory-efficient way to compute sample means and
variances when you have a function that generates individual samples. Instead
of storing all samples in memory, it updates running statistics incrementally.
}
\details{
Welford's algorithm computes mean and variance in a single pass without
storing all samples. This is numerically stable and memory-efficient.

The variance returned is the variance of the sample mean (i.e., divided by n),
not the sample variance. This is appropriate for Monte Carlo simulation where
we want to quantify uncertainty in the mean estimate.

Memory usage: O(m) where m is the number of metrics, regardless of n_samples.
}
\examples{
\dontrun{
# Example: Simulate a clinical trial outcome
simulate_trial <- function(i, theta) {
  # Simulate one trial with given parameters
  success <- rbinom(1, 1, theta$prob)
  sample_size <- rpois(1, theta$expected_n)
  c(power = success, EN = sample_size)
}

# Compute mean and variance over 1000 simulations
result <- welford_mean_var(
  sample_fn = simulate_trial,
  n_samples = 1000,
  theta = list(prob = 0.8, expected_n = 100)
)

# Use in your simulator:
sim_fun <- function(theta, fidelity = "high", ...) {
  n_rep <- switch(fidelity, low = 200, med = 1000, high = 10000)

  result <- welford_mean_var(
    sample_fn = function(i, theta) {
      trial <- run_one_trial(theta)
      c(power = trial$power, EN = trial$sample_size)
    },
    n_samples = n_rep,
    theta = theta
  )

  metrics <- result$mean
  attr(metrics, "variance") <- result$variance
  attr(metrics, "n_rep") <- n_rep
  return(metrics)
}
}

}
\references{
Welford, B. P. (1962). "Note on a method for calculating corrected sums of
squares and products". Technometrics. 4 (3): 419â€“420.
}
